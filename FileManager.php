<?php

declare(strict_types=1);

namespace MakinaCorpus\FilechunkBundle;

use Symfony\Component\HttpFoundation\File\File;

final class FileManager
{
    const SCHEME_LOCAL = 'file';
    const SCHEME_PRIVATE = 'private';
    const SCHEME_PUBLIC = 'public';
    const SCHEME_TEMPORARY = 'temporary';
    const SCHEME_UPLOAD = 'upload';

    /**
     * @var array
     *   Keys are schemes (such as "file" or "public") values are the working
     *   directory. Directory could itself be using a scheme (such as "sftp://")
     *   for example, as long as PHP can handle those natively with its stream
     *   wrapper API.
     */
    private $knownSchemes = [];

    /**
     * Default constructor
     */
    public function __construct(array $knownSchemes = [])
    {
        foreach ($knownSchemes as $scheme => $workindDirectory) {
            if (!\preg_match('@^[a-z0-9]+$@i', $scheme)) {
                throw new \InvalidArgumentException(\sprintf(
                    "Invalid scheme provided: '%s', it must only contains letters or numbers and cannot be empty",
                    $scheme
                ));
            }
            $this->knownSchemes[$scheme] = self::normalizePath($workindDirectory);
        }
        // Sort by descending length (longer first) - this makes natural the
        // nested scheme targets de-ambiguation when looking up for a matching
        // scheme from an absolute filename.
        \uasort($this->knownSchemes, function ($a, $b) {
            return \strlen($b) - \strlen($a);
        });
    }

    private static function unknownScheme(string $scheme): string
    {
        throw new \InvalidArgumentException(\sprintf("Scheme '%s' is unknown", $scheme));
    }

    /**
     * Get known schemes
     */
    public function getKnownSchemes(): array
    {
        return $this->knownSchemes;
    }

    /**
     * Get scheme from URI
     */
    public static function getScheme(string $uri): ?string
    {
        // Skip false (not found) or 0 (start offset, no scheme)
        if ($pos = \strpos($uri, '://')) {
            return \substr($uri, 0, $pos);
        }
        return null;
    }

    /**
     * Strip scheme from URI
     */
    public static function stripScheme(string $uri): string
    {
        // Skip false (not found) or 0 (start offset, no scheme)
        if ($pos = \strpos($uri, '://')) {
            return \substr($uri, $pos + 3);
        }
        return $uri;
    }

    /**
     * Normalize a path by removing redundant '..', '.' and '/' and thus preventing the
     * need of using the realpath() function that may come with some side effects such
     * as breaking out open_basedir configuration by attempting to following symlinks
     */
    public static function normalizePath(string $string): string
    {
        // Handle windows gracefully
        if (DIRECTORY_SEPARATOR !== '/') {
            $string = \str_replace(DIRECTORY_SEPARATOR, '/', $string);
        }
        // Also tests some special cases we can't really do anything with
        if (false === \strpos($string, '/') || '/' === $string || '.' === $string || '..' === $string) {
            return $string;
        }
        // This is supposedly invalid, but an empty string is an empty string
        if ('' === ($string = \rtrim($string, '/'))) {
            return '';
        }
        $scheme = null;
        if (\strpos($string, '://')) {
            list($scheme, $string) = \explode('://', $string, 2);
        }
        // Matches useless '.' repetitions
        $string = \preg_replace('@^\./|(/\.)+/|/\.$@', '/', $string);
        $count = 0;
        do {
            // string such as '//' can be generated by the first regex, hence the second 
            $string = \preg_replace('@[^/]+/+\.\.(/+|$)@', '$2', \preg_replace('@//+@', '/', $string), -1, $count);
        } while ($count);
        // rtrim() a second time because preg_replace() could leave a trailing '/'
        return ($scheme ? ($scheme.'://') : '').\rtrim($string, '/');
    }

    /**
     * Strip local scheme (aka "file://" will be dropped from URI if found).
     */
    public static function stripLocalScheme(string $uri): string
    {
        if ('f' === $uri[0] /* speed! */ && 'file://' === \substr($uri, 0, 7)) {
            return \substr($uri, 7);
        }
        return $uri;
    }

    /**
     * Implementation of identify() working with an already normalized URI.
     */
    private function identifyNormalized(string $uri): ?SchemeURI
    {
        $scheme = $this->getScheme($uri);

        // Deal with specific "file" scheme which means file within the local
        // filesystem, always strip it.
        if (self::SCHEME_LOCAL === $scheme) {
            $uri = \sprintf('/%s', \trim(\substr($uri, \strlen(self::SCHEME_LOCAL) + 3), '/'));
            $scheme = null;
        }

        if ($scheme) {
            if (isset($this->knownSchemes[$scheme])) {
                // Trim leading '/' to avoid double '/' in generated absolute path.
                return new SchemeURI($scheme, \ltrim(self::stripScheme($uri), '/'), $this->knownSchemes[$scheme]);
            } else {
                return null;
            }
        }

        // Dynamic lookup
        // De-ambiguation when a scheme working directory is nested within another
        // scheme working directory is natural because we sorted the known schemes
        // by working directory descending order.
        foreach ($this->knownSchemes as $scheme => $workingDirectory) {
            $length = \strlen($workingDirectory);
            if ($workingDirectory === \substr($uri, 0, $length)) {
                // Trim leading '/' to avoid double '/' in generated absolute path.
                return new SchemeURI($scheme, \ltrim(\substr($uri, $length), '/'), $workingDirectory);
            }
        }

        return null;
    }

    /**
     * Get working directory for scheme
     */
    public function getWorkingDirectory(string $scheme): string
    {
        return $this->knownSchemes[$scheme] ?? self::unknownScheme($scheme);
    }

    /**
     * Is given scheme known
     */
    public function isKnownScheme(string $scheme): bool
    {
        return isset($this->knownSchemes[$scheme]);
    }

    /**
     * Get working directory of given scheme or URI.
     *
     * If an URI outside of a known scheme, an absolute URI, a relative URI
     * without scheme, or an unknown scheme is given, this will return null.
     */
    public function identify(string $uri): ?SchemeURI
    {
        return $this->identifyNormalized(self::normalizePath($uri));
    }

    /**
     * Is given filename or URI within the given path
     */
    public function isPathWithin(string $uri, string $directory): bool
    {
        return 0 === \strpos($this->getAbsolutePath($uri), $this->getAbsolutePath($directory));
    }

    /**
     * Get given filename or URI relative path to given directory
     */
    public function getRelativePathFrom(string $uri, string $directory): ?string
    {
        $uri = $this->getAbsolutePath($uri);
        $directory = $this->getAbsolutePath($directory);
        $length = \strlen($directory);

        if (\substr($uri, 0, $length) !== $directory) {
            return null;
        }

        return \ltrim(\substr($uri, $length), '/');
    }

    /**
     * Get relative URI of file, relative to its working directory.
     *
     * If an URI outside of a known scheme, an absolute URI, a relative URI
     * without scheme, or an unknown scheme is given, it will be returned as-is
     * but just normalized.
     */
    public function getAbsolutePath(string $uri): string
    {
        $uri = self::normalizePath($uri);

        if ($identity = $this->identifyNormalized($uri)) {
            return $identity->getAbsolutePath();
        }

        return $uri;
  }

    /**
     * Get URI from filename.
     *
     * If an URI outside of a known scheme, an absolute URI, a relative URI
     * without scheme, or an unknown scheme is given, it will be returned as-is
     * but just normalized.
     */
    public function getURI(string $filename): string
    {
        $filename = self::normalizePath($filename);

        if ($identity = $this->identifyNormalized($filename)) {
            return (string)$identity;
        }

        return $filename;
    }

    /**
     * Create file instance from given URI
     */
    public function createFile(string $uri, bool $checkpath = true): File
    {
        return new File($this->getAbsolutePath($uri), $checkpath);
    }
}

/**
 * Represents a file with scheme match
 */
final class SchemeURI
{
    private $relativeURI;
    private $scheme;
    private $workingDirectory;

    public function __construct(string $scheme, string $relativeURI, string $workingDirectory)
    {
        $this->relativeURI = $relativeURI;
        $this->scheme = $scheme;
        $this->workingDirectory = $workingDirectory;
    }

    /**
     * Get URI scheme relative path
     */
    public function getRelativePath(): string
    {
        return $this->relativeURI;
    }

    /**
     * Get scheme working directory
     */
    public function getWorkingDirectory(): string
    {
        return $this->workingDirectory;
    }

    /**
     * Get URI scheme
     */
    public function getScheme(): string
    {
        return $this->scheme;
    }

    /**
     * Get URI absolute path
     */
    public function getAbsolutePath(): string
    {
        return \sprintf("%s/%s", $this->workingDirectory, $this->relativeURI);
    }

    /**
     * URI representation with scheme
     */
    public function __toString(): string
    {
        return \sprintf("%s://%s", $this->scheme, $this->relativeURI);
    }
}
