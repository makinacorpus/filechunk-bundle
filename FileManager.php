<?php

declare(strict_types=1);

namespace MakinaCorpus\FilechunkBundle;

use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\HttpFoundation\File\File;

/**
 * This is a minimalistic backport from 2.x for fixing the Symfony form type.
 */
final class FileManager
{
    /**
     * We need this for stream wrappers.
     */
    private static $instance;

    /**
     * Default constructor
     */
    public function __construct()
    {
        self::initializeEnvironment($this);
    }

    /**
     * Register static singleton
     */
    private static function initializeEnvironment(self $instance)
    {
        self::$instance = $instance;
    }

    /**
     * Get instance
     */
    public static function getInstance(): FileManager
    {
        if (!self::$instance) {
            throw new \LogicException(\sprintf("'%s' instance must be programtically instanciated before using the static singleton", __CLASS__));
        }
        return self::$instance;
    }

    /**
     * Normalize a path by removing redundant '..', '.' and '/' and thus preventing the
     * need of using the realpath() function that may come with some side effects such
     * as breaking out open_basedir configuration by attempting to following symlinks
     */
    public static function normalizePath(string $string): string
    {
        // Handle windows gracefully
        if (DIRECTORY_SEPARATOR !== '/') {
            $string = \str_replace(DIRECTORY_SEPARATOR, '/', $string);
        }
        // Also tests some special cases we can't really do anything with
        if (false === \strpos($string, '/') || '/' === $string || '.' === $string || '..' === $string) {
            return $string;
        }
        // This is supposedly invalid, but an empty string is an empty string
        if ('' === ($string = \rtrim($string, '/'))) {
            return '';
        }
        $scheme = null;
        if (\strpos($string, '://')) {
            list($scheme, $string) = \explode('://', $string, 2);
        }
        // Matches useless '.' repetitions
        $string = \preg_replace('@^\./|(/\.)+/|/\.$@', '/', $string);
        $count = 0;
        do {
            // string such as '//' can be generated by the first regex, hence the second 
            $string = \preg_replace('@[^/]+/+\.\.(/+|$)@', '$2', \preg_replace('@//+@', '/', $string), -1, $count);
        } while ($count);
        // rtrim() a second time because preg_replace() could leave a trailing '/'
        return ($scheme ? ($scheme.'://') : '').\rtrim($string, '/');
    }

    /**
     * Does file or directory exists.
     */
    public function exists(string $uri): bool
    {
        return (new Filesystem())->exists($this->getAbsolutePath($uri));
    }

    /**
     * Get relative URI of file, relative to its working directory.
     *
     * If an URI outside of a known scheme, an absolute URI, a relative URI
     * without scheme, or an unknown scheme is given, it will be returned as-is
     * but just normalized.
     */
    public function getAbsolutePath(string $uri): string
    {
        return self::normalizePath($uri);
  }

    /**
     * Get URI from filename.
     *
     * If an URI outside of a known scheme, an absolute URI, a relative URI
     * without scheme, or an unknown scheme is given, it will be returned as-is
     * but just normalized.
     */
    public function getURI(string $filename): string
    {
        return self::normalizePath($filename);
    }

    /**
     * Create file instance from given URI
     */
    public function createFile(string $uri, bool $checkpath = true): File
    {
        return new File($this->getAbsolutePath($uri), $checkpath);
    }
}
